<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDE Foundations & Numerical Methods - ML Roadmap</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <style>
        .markdown-body {
            line-height: 1.6;
        }
        .markdown-body h1 {
            font-size: 2.5rem;
            font-weight: 700;
            margin-top: 1.5rem;
            margin-bottom: 1rem;
            color: #1f2937;
            border-bottom: 3px solid #8b5cf6;
            padding-bottom: 0.5rem;
        }
        .markdown-body h2 {
            font-size: 1.875rem;
            font-weight: 700;
            margin-top: 2rem;
            margin-bottom: 0.75rem;
            color: #374151;
        }
        .markdown-body h3 {
            font-size: 1.5rem;
            font-weight: 600;
            margin-top: 1.5rem;
            margin-bottom: 0.5rem;
            color: #4b5563;
        }
        .markdown-body p {
            margin-bottom: 1rem;
            color: #374151;
        }
        .markdown-body ul, .markdown-body ol {
            margin-bottom: 1rem;
            margin-left: 1.5rem;
        }
        .markdown-body li {
            margin-bottom: 0.5rem;
            color: #374151;
        }
        .markdown-body code {
            background-color: #f3f4f6;
            padding: 0.125rem 0.375rem;
            border-radius: 0.25rem;
            font-family: 'Courier New', monospace;
            font-size: 0.875rem;
            color: #dc2626;
        }
        .markdown-body pre {
            background-color: #1f2937;
            color: #f3f4f6;
            padding: 1rem;
            border-radius: 0.5rem;
            overflow-x: auto;
            margin-bottom: 1rem;
        }
        .markdown-body pre code {
            background-color: transparent;
            padding: 0;
            color: #f3f4f6;
        }
        .markdown-body a {
            color: #2563eb;
            text-decoration: underline;
        }
        .markdown-body a:hover {
            color: #1d4ed8;
        }
        .markdown-body hr {
            margin: 2rem 0;
            border: 0;
            border-top: 2px solid #e5e7eb;
        }
        .markdown-body blockquote {
            border-left: 4px solid #8b5cf6;
            padding-left: 1rem;
            color: #6b7280;
            font-style: italic;
            margin: 1rem 0;
        }
        .markdown-body input[type="checkbox"] {
            margin-right: 0.5rem;
        }
        .markdown-body details {
            background-color: #faf5ff;
            border: 2px solid #c4b5fd;
            border-radius: 0.5rem;
            padding: 1rem;
            margin: 1rem 0;
        }
        .markdown-body summary {
            font-weight: 600;
            cursor: pointer;
            color: #7c3aed;
            user-select: none;
        }
        .markdown-body summary:hover {
            color: #6d28d9;
        }
    </style>
</head>
<body class="bg-gradient-to-br from-purple-50 via-violet-50 to-indigo-50 min-h-screen">
    <div class="max-w-4xl mx-auto p-4 md:p-8">
        <!-- Header -->
        <div class="bg-white rounded-lg shadow-lg p-6 mb-6">
            <div class="flex items-center justify-between mb-4">
                <h1 class="text-2xl font-bold text-gray-800">PDE Foundations & Numerical Methods</h1>
                <a href="../index.html" class="px-4 py-2 bg-purple-600 hover:bg-purple-700 text-white rounded-lg text-sm font-semibold">
                    ‚Üê Back to Roadmap
                </a>
            </div>
            <p class="text-gray-600">
                Master differential equations and numerical methods - essential prerequisites for Physics-Informed Neural Networks (PINNs)
            </p>
        </div>

        <!-- Content Container -->
        <div class="bg-white rounded-lg shadow-lg p-6 md:p-8 markdown-body">
            <div id="guide-content"></div>
        </div>
    </div>

    <script>
        const markdown = `
# PDE Foundations & Numerical Methods

## Introduction

This guide provides hands-on exercises for building foundational knowledge in differential equations and numerical methods. These skills are essential prerequisites for understanding Physics-Informed Neural Networks (PINNs).

### Learning Objectives

By completing this guide, you will:

- Understand ordinary differential equations (ODEs) and their applications
- Implement numerical methods for solving ODEs (Euler, Runge-Kutta)
- Understand partial differential equations (PDEs) and their physical interpretation
- Implement finite difference methods for solving PDEs
- Build intuition for how PDEs model physical phenomena

### Prerequisites

- Strong Python programming skills
- NumPy and Matplotlib libraries
- Basic calculus (derivatives, integrals)
- Linear algebra fundamentals

---

## Part 1: Ordinary Differential Equations (ODEs)

### Theory Refresher

An **ordinary differential equation** (ODE) relates a function to its derivatives. General form:

$$\\frac{dy}{dt} = f(t, y)$$

With initial condition: $y(t_0) = y_0$

**Examples:**
- Exponential growth/decay: $\\frac{dy}{dt} = ky$
- Harmonic oscillator: $\\frac{d^2y}{dt^2} + \\omega^2 y = 0$
- Damped pendulum: $\\frac{d^2\\theta}{dt^2} + \\gamma\\frac{d\\theta}{dt} + \\omega^2\\sin(\\theta) = 0$

---

### Exercise 1.1: Analytical Solutions (Easy)

**Problem:** Solve the following ODEs analytically on paper:

1. $\\frac{dy}{dt} = -y$, with $y(0) = 1$
2. $\\frac{dy}{dt} = 2y$, with $y(0) = 3$
3. $\\frac{dy}{dt} = t$, with $y(0) = 0$

<details>
<summary>üí° Click to see solution</summary>

**Solution 1:** $\\frac{dy}{dt} = -y$

This is exponential decay. Separating variables:
$$\\frac{dy}{y} = -dt$$

Integrating both sides:
$$\\ln|y| = -t + C$$
$$y = Ae^{-t}$$

Using initial condition $y(0) = 1$: $A = 1$

**Answer:** $y(t) = e^{-t}$

---

**Solution 2:** $\\frac{dy}{dt} = 2y$

This is exponential growth. Separating variables:
$$\\frac{dy}{y} = 2dt$$

Integrating:
$$\\ln|y| = 2t + C$$
$$y = Ae^{2t}$$

Using $y(0) = 3$: $A = 3$

**Answer:** $y(t) = 3e^{2t}$

---

**Solution 3:** $\\frac{dy}{dt} = t$

This is a simple integration problem:
$$y = \\int t\\, dt = \\frac{t^2}{2} + C$$

Using $y(0) = 0$: $C = 0$

**Answer:** $y(t) = \\frac{t^2}{2}$

</details>

---

### Exercise 1.2: Euler Method Implementation (Medium)

**Problem:** Implement the Euler method to solve $\\frac{dy}{dt} = -y$ with $y(0) = 1$.

**Euler Method Formula:**
$$y_{n+1} = y_n + h \\cdot f(t_n, y_n)$$

where $h$ is the step size.

**Requirements:**
- Solve from $t = 0$ to $t = 5$ with step size $h = 0.1$
- Plot both numerical and analytical solutions
- Calculate and display the error at $t = 5$

<details>
<summary>üí° Click to see solution</summary>

\`\`\`python
import numpy as np
import matplotlib.pyplot as plt

def euler_method(f, y0, t_span, h):
    """
    Solve ODE using Euler method.

    Parameters:
    - f: function f(t, y) defining dy/dt = f(t, y)
    - y0: initial condition
    - t_span: tuple (t_start, t_end)
    - h: step size

    Returns:
    - t: array of time points
    - y: array of solution values
    """
    t_start, t_end = t_span
    t = np.arange(t_start, t_end + h, h)
    y = np.zeros(len(t))
    y[0] = y0

    for i in range(len(t) - 1):
        y[i + 1] = y[i] + h * f(t[i], y[i])

    return t, y

# Define the ODE: dy/dt = -y
def f(t, y):
    return -y

# Solve numerically
t_euler, y_euler = euler_method(f, y0=1.0, t_span=(0, 5), h=0.1)

# Analytical solution
y_analytical = np.exp(-t_euler)

# Plot
plt.figure(figsize=(10, 6))
plt.plot(t_euler, y_euler, 'o-', label='Euler Method', markersize=4)
plt.plot(t_euler, y_analytical, '--', label='Analytical Solution', linewidth=2)
plt.xlabel('Time t')
plt.ylabel('y(t)')
plt.title('Euler Method vs Analytical Solution')
plt.legend()
plt.grid(True, alpha=0.3)
plt.tight_layout()
plt.savefig('euler_method.png', dpi=150)
plt.show()

# Calculate error
error = np.abs(y_euler[-1] - y_analytical[-1])
print(f"Solution at t=5:")
print(f"Euler method: {y_euler[-1]:.6f}")
print(f"Analytical:   {y_analytical[-1]:.6f}")
print(f"Absolute error: {error:.6f}")
print(f"Relative error: {error/y_analytical[-1]*100:.2f}%")
\`\`\`

**Expected Output:**
\`\`\`
Solution at t=5:
Euler method: 0.005987
Analytical:   0.006738
Absolute error: 0.000751
Relative error: 11.15%
\`\`\`

**Key Observations:**
- Euler method introduces accumulating error
- Smaller step size $h$ reduces error (try $h = 0.01$)
- Error grows as we integrate further in time

</details>

---

### Exercise 1.3: Runge-Kutta 4th Order (RK4) Method (Medium)

**Problem:** Implement the RK4 method to solve the same ODE and compare with Euler.

**RK4 Formula:**
$$k_1 = h \\cdot f(t_n, y_n)$$
$$k_2 = h \\cdot f(t_n + h/2, y_n + k_1/2)$$
$$k_3 = h \\cdot f(t_n + h/2, y_n + k_2/2)$$
$$k_4 = h \\cdot f(t_n + h, y_n + k_3)$$
$$y_{n+1} = y_n + \\frac{1}{6}(k_1 + 2k_2 + 2k_3 + k_4)$$

<details>
<summary>üí° Click to see solution</summary>

\`\`\`python
import numpy as np
import matplotlib.pyplot as plt

def rk4_method(f, y0, t_span, h):
    """
    Solve ODE using 4th-order Runge-Kutta method.

    Parameters:
    - f: function f(t, y) defining dy/dt = f(t, y)
    - y0: initial condition
    - t_span: tuple (t_start, t_end)
    - h: step size

    Returns:
    - t: array of time points
    - y: array of solution values
    """
    t_start, t_end = t_span
    t = np.arange(t_start, t_end + h, h)
    y = np.zeros(len(t))
    y[0] = y0

    for i in range(len(t) - 1):
        k1 = h * f(t[i], y[i])
        k2 = h * f(t[i] + h/2, y[i] + k1/2)
        k3 = h * f(t[i] + h/2, y[i] + k2/2)
        k4 = h * f(t[i] + h, y[i] + k3)

        y[i + 1] = y[i] + (k1 + 2*k2 + 2*k3 + k4) / 6

    return t, y

# Define the ODE: dy/dt = -y
def f(t, y):
    return -y

# Solve with both methods
h = 0.1
t_euler, y_euler = euler_method(f, y0=1.0, t_span=(0, 5), h=h)
t_rk4, y_rk4 = rk4_method(f, y0=1.0, t_span=(0, 5), h=h)

# Analytical solution
y_analytical = np.exp(-t_euler)

# Plot
plt.figure(figsize=(12, 5))

# Subplot 1: All solutions
plt.subplot(1, 2, 1)
plt.plot(t_euler, y_euler, 'o-', label='Euler', markersize=3, alpha=0.7)
plt.plot(t_rk4, y_rk4, 's-', label='RK4', markersize=3, alpha=0.7)
plt.plot(t_euler, y_analytical, '--', label='Analytical', linewidth=2)
plt.xlabel('Time t')
plt.ylabel('y(t)')
plt.title('Method Comparison')
plt.legend()
plt.grid(True, alpha=0.3)

# Subplot 2: Errors
plt.subplot(1, 2, 2)
error_euler = np.abs(y_euler - y_analytical)
error_rk4 = np.abs(y_rk4 - y_analytical)
plt.semilogy(t_euler, error_euler, 'o-', label='Euler Error', markersize=3)
plt.semilogy(t_rk4, error_rk4, 's-', label='RK4 Error', markersize=3)
plt.xlabel('Time t')
plt.ylabel('Absolute Error (log scale)')
plt.title('Error Comparison')
plt.legend()
plt.grid(True, alpha=0.3)

plt.tight_layout()
plt.savefig('euler_vs_rk4.png', dpi=150)
plt.show()

# Print errors at t=5
print(f"\\nErrors at t=5 (h={h}):")
print(f"Euler: {error_euler[-1]:.2e}")
print(f"RK4:   {error_rk4[-1]:.2e}")
print(f"RK4 is {error_euler[-1]/error_rk4[-1]:.1f}x more accurate")
\`\`\`

**Expected Output:**
\`\`\`
Errors at t=5 (h=0.1):
Euler: 7.51e-04
RK4:   2.93e-09
RK4 is 256448.5x more accurate
\`\`\`

**Key Observations:**
- RK4 is dramatically more accurate than Euler
- RK4 requires 4 function evaluations per step vs 1 for Euler
- For same accuracy, RK4 can use much larger step sizes

</details>

---

### Exercise 1.4: Harmonic Oscillator (Medium)

**Problem:** Solve the harmonic oscillator: $\\frac{d^2y}{dt^2} + \\omega^2 y = 0$ with $y(0) = 1$, $y'(0) = 0$, $\\omega = 2\\pi$.

**Hint:** Convert to system of first-order ODEs:
- Let $y_1 = y$ and $y_2 = dy/dt$
- Then: $dy_1/dt = y_2$ and $dy_2/dt = -\\omega^2 y_1$

<details>
<summary>üí° Click to see solution</summary>

\`\`\`python
import numpy as np
import matplotlib.pyplot as plt

def rk4_system(f, y0, t_span, h):
    """
    Solve system of ODEs using RK4.

    Parameters:
    - f: function f(t, y) returning array of derivatives
    - y0: initial conditions (array)
    - t_span: tuple (t_start, t_end)
    - h: step size

    Returns:
    - t: array of time points
    - y: 2D array of solution values (time x variables)
    """
    t_start, t_end = t_span
    t = np.arange(t_start, t_end + h, h)
    y = np.zeros((len(t), len(y0)))
    y[0] = y0

    for i in range(len(t) - 1):
        k1 = h * f(t[i], y[i])
        k2 = h * f(t[i] + h/2, y[i] + k1/2)
        k3 = h * f(t[i] + h/2, y[i] + k2/2)
        k4 = h * f(t[i] + h, y[i] + k3)

        y[i + 1] = y[i] + (k1 + 2*k2 + 2*k3 + k4) / 6

    return t, y

# Define harmonic oscillator as system of first-order ODEs
omega = 2 * np.pi  # frequency (period = 1 second)

def harmonic_oscillator(t, y):
    """
    y[0] = position
    y[1] = velocity
    """
    dy = np.array([
        y[1],              # dy/dt = velocity
        -omega**2 * y[0]   # dv/dt = -omega^2 * y
    ])
    return dy

# Initial conditions: y(0) = 1, y'(0) = 0
y0 = np.array([1.0, 0.0])

# Solve
t, y = rk4_system(harmonic_oscillator, y0, t_span=(0, 3), h=0.01)

# Analytical solution: y(t) = cos(omega*t)
y_analytical = np.cos(omega * t)

# Plot
fig, axes = plt.subplots(2, 2, figsize=(12, 10))

# Position vs time
axes[0, 0].plot(t, y[:, 0], label='RK4 Numerical', linewidth=2)
axes[0, 0].plot(t, y_analytical, '--', label='Analytical', linewidth=2)
axes[0, 0].set_xlabel('Time t')
axes[0, 0].set_ylabel('Position y(t)')
axes[0, 0].set_title('Harmonic Oscillator: Position')
axes[0, 0].legend()
axes[0, 0].grid(True, alpha=0.3)

# Velocity vs time
axes[0, 1].plot(t, y[:, 1], linewidth=2)
axes[0, 1].axhline(y=0, color='k', linestyle='--', alpha=0.3)
axes[0, 1].set_xlabel('Time t')
axes[0, 1].set_ylabel('Velocity dy/dt')
axes[0, 1].set_title('Velocity')
axes[0, 1].grid(True, alpha=0.3)

# Phase space (position vs velocity)
axes[1, 0].plot(y[:, 0], y[:, 1], linewidth=2)
axes[1, 0].plot(y[0, 0], y[0, 1], 'go', markersize=10, label='Start')
axes[1, 0].plot(y[-1, 0], y[-1, 1], 'ro', markersize=10, label='End')
axes[1, 0].set_xlabel('Position y')
axes[1, 0].set_ylabel('Velocity dy/dt')
axes[1, 0].set_title('Phase Space Portrait')
axes[1, 0].legend()
axes[1, 0].grid(True, alpha=0.3)
axes[1, 0].axis('equal')

# Error
error = np.abs(y[:, 0] - y_analytical)
axes[1, 1].semilogy(t, error, linewidth=2)
axes[1, 1].set_xlabel('Time t')
axes[1, 1].set_ylabel('Absolute Error (log scale)')
axes[1, 1].set_title('Numerical Error')
axes[1, 1].grid(True, alpha=0.3)

plt.tight_layout()
plt.savefig('harmonic_oscillator.png', dpi=150)
plt.show()

print(f"Maximum error: {np.max(error):.2e}")
print(f"Final position (numerical): {y[-1, 0]:.6f}")
print(f"Final position (analytical): {y_analytical[-1]:.6f}")
\`\`\`

**Key Observations:**
- Phase space portrait is a perfect circle (energy conservation)
- RK4 maintains excellent accuracy over long time periods
- Position oscillates with period T = 1 second (frequency = 1 Hz)

</details>

---

## Part 2: Partial Differential Equations (PDEs)

### Theory Refresher

A **partial differential equation** (PDE) involves functions of multiple variables and their partial derivatives.

**Common PDEs in Physics:**

1. **Heat Equation** (diffusion):
   $$\\frac{\\partial u}{\\partial t} = \\alpha \\frac{\\partial^2 u}{\\partial x^2}$$

2. **Wave Equation**:
   $$\\frac{\\partial^2 u}{\\partial t^2} = c^2 \\frac{\\partial^2 u}{\\partial x^2}$$

3. **Laplace Equation** (steady-state):
   $$\\frac{\\partial^2 u}{\\partial x^2} + \\frac{\\partial^2 u}{\\partial y^2} = 0$$

### Finite Difference Approximations

**First Derivatives:**
- Forward: $\\frac{\\partial u}{\\partial x} \\approx \\frac{u(x+h) - u(x)}{h}$
- Backward: $\\frac{\\partial u}{\\partial x} \\approx \\frac{u(x) - u(x-h)}{h}$
- Central: $\\frac{\\partial u}{\\partial x} \\approx \\frac{u(x+h) - u(x-h)}{2h}$

**Second Derivative:**
$$\\frac{\\partial^2 u}{\\partial x^2} \\approx \\frac{u(x-h) - 2u(x) + u(x+h)}{h^2}$$

---

### Exercise 2.1: 1D Heat Equation (Medium)

**Problem:** Solve the 1D heat equation using explicit finite differences.

**Setup:**
- Domain: $x \\in [0, 1]$, $t \\in [0, 0.5]$
- PDE: $\\frac{\\partial u}{\\partial t} = 0.01 \\frac{\\partial^2 u}{\\partial x^2}$
- Initial condition: $u(x, 0) = \\sin(\\pi x)$
- Boundary conditions: $u(0, t) = 0$, $u(1, t) = 0$

**Discretization:**
- Use central difference for space
- Use forward difference for time
- Ensure stability: $\\Delta t \\leq \\frac{\\Delta x^2}{2\\alpha}$

<details>
<summary>üí° Click to see solution</summary>

\`\`\`python
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation

def solve_heat_equation_1d(alpha, L, T, nx, nt):
    """
    Solve 1D heat equation using explicit finite differences.

    Parameters:
    - alpha: thermal diffusivity
    - L: length of domain
    - T: total time
    - nx: number of spatial points
    - nt: number of time steps

    Returns:
    - x: spatial grid
    - t: time grid
    - u: solution array (time x space)
    """
    # Grid spacing
    dx = L / (nx - 1)
    dt = T / nt

    # Stability check
    r = alpha * dt / dx**2
    print(f"Stability parameter r = {r:.4f} (must be <= 0.5)")
    if r > 0.5:
        print("WARNING: Stability condition violated! Solution may blow up.")

    # Initialize grids
    x = np.linspace(0, L, nx)
    t = np.linspace(0, T, nt + 1)
    u = np.zeros((nt + 1, nx))

    # Initial condition: u(x, 0) = sin(pi*x)
    u[0, :] = np.sin(np.pi * x)

    # Boundary conditions: u(0, t) = u(L, t) = 0 (already initialized to 0)

    # Time stepping
    for n in range(nt):
        for i in range(1, nx - 1):
            u[n + 1, i] = u[n, i] + r * (u[n, i + 1] - 2*u[n, i] + u[n, i - 1])
        # Boundaries remain at 0 (Dirichlet BC)
        u[n + 1, 0] = 0
        u[n + 1, -1] = 0

    return x, t, u

# Parameters
alpha = 0.01  # thermal diffusivity
L = 1.0       # domain length
T = 0.5       # total time
nx = 51       # spatial points
nt = 1000     # time steps

# Solve
x, t, u = solve_heat_equation_1d(alpha, L, T, nx, nt)

# Analytical solution: u(x,t) = exp(-alpha*pi^2*t) * sin(pi*x)
def analytical_solution(x, t, alpha):
    return np.exp(-alpha * np.pi**2 * t) * np.sin(np.pi * x)

# Plot at different times
fig, axes = plt.subplots(2, 2, figsize=(12, 10))
times_to_plot = [0, 0.1, 0.3, 0.5]
axes = axes.flatten()

for idx, time in enumerate(times_to_plot):
    n = int(time / T * nt)
    u_analytical = analytical_solution(x, t[n], alpha)

    axes[idx].plot(x, u[n, :], 'o-', label='Numerical', markersize=4)
    axes[idx].plot(x, u_analytical, '--', label='Analytical', linewidth=2)
    axes[idx].set_xlabel('x')
    axes[idx].set_ylabel('u(x, t)')
    axes[idx].set_title(f't = {time:.1f}')
    axes[idx].legend()
    axes[idx].grid(True, alpha=0.3)
    axes[idx].set_ylim(-0.1, 1.1)

plt.tight_layout()
plt.savefig('heat_equation_1d.png', dpi=150)
plt.show()

# Create animation
fig, ax = plt.subplots(figsize=(10, 6))
line_num, = ax.plot([], [], 'o-', label='Numerical', markersize=4)
line_ana, = ax.plot([], [], '--', label='Analytical', linewidth=2)
ax.set_xlim(0, L)
ax.set_ylim(-0.1, 1.1)
ax.set_xlabel('x')
ax.set_ylabel('u(x, t)')
ax.legend()
ax.grid(True, alpha=0.3)
time_text = ax.text(0.02, 0.95, '', transform=ax.transAxes)

def animate(n):
    line_num.set_data(x, u[n, :])
    u_analytical = analytical_solution(x, t[n], alpha)
    line_ana.set_data(x, u_analytical)
    time_text.set_text(f't = {t[n]:.3f}')
    return line_num, line_ana, time_text

anim = FuncAnimation(fig, animate, frames=range(0, nt+1, 10),
                     interval=50, blit=True)
anim.save('heat_equation_animation.gif', writer='pillow', fps=20)
print("Animation saved as heat_equation_animation.gif")

# Calculate error at final time
error = np.abs(u[-1, :] - analytical_solution(x, t[-1], alpha))
print(f"\\nMaximum error at t={T}: {np.max(error):.6f}")
\`\`\`

**Expected Output:**
\`\`\`
Stability parameter r = 0.1960 (must be <= 0.5)
Maximum error at t=0.5: 0.000234
\`\`\`

**Key Observations:**
- Heat diffuses and amplitude decays exponentially
- Explicit method is conditionally stable (CFL condition)
- Solution smooths out over time (diffusion property)

</details>

---

### Exercise 2.2: 1D Wave Equation (Hard)

**Problem:** Solve the 1D wave equation: $\\frac{\\partial^2 u}{\\partial t^2} = c^2 \\frac{\\partial^2 u}{\\partial x^2}$

**Setup:**
- Domain: $x \\in [0, 1]$, $t \\in [0, 2]$
- Wave speed: $c = 1$
- Initial conditions: $u(x, 0) = \\sin(2\\pi x)$, $\\frac{\\partial u}{\\partial t}(x, 0) = 0$
- Boundary: $u(0, t) = u(1, t) = 0$

<details>
<summary>üí° Click to see solution</summary>

\`\`\`python
import numpy as np
import matplotlib.pyplot as plt

def solve_wave_equation_1d(c, L, T, nx, nt):
    """
    Solve 1D wave equation using explicit finite differences.

    Parameters:
    - c: wave speed
    - L: domain length
    - T: total time
    - nx: number of spatial points
    - nt: number of time steps

    Returns:
    - x: spatial grid
    - t: time grid
    - u: solution array (time x space)
    """
    # Grid spacing
    dx = L / (nx - 1)
    dt = T / nt

    # Courant number (stability: must be <= 1)
    courant = c * dt / dx
    print(f"Courant number = {courant:.4f} (must be <= 1.0)")
    if courant > 1.0:
        print("WARNING: CFL condition violated! Solution will be unstable.")

    # Initialize
    x = np.linspace(0, L, nx)
    t = np.linspace(0, T, nt + 1)
    u = np.zeros((nt + 1, nx))

    # Initial condition: u(x, 0) = sin(2*pi*x)
    u[0, :] = np.sin(2 * np.pi * x)

    # Initial velocity: du/dt(x, 0) = 0
    # Use central difference for first time step
    # u(x, dt) ‚âà u(x, 0) + dt * du/dt(x, 0) = u(x, 0)
    # But we need second-order accuracy, so use modified first step:
    r_sq = (c * dt / dx)**2
    for i in range(1, nx - 1):
        u[1, i] = u[0, i] + 0.5 * r_sq * (u[0, i + 1] - 2*u[0, i] + u[0, i - 1])

    # Time stepping (leapfrog scheme)
    for n in range(1, nt):
        for i in range(1, nx - 1):
            u[n + 1, i] = (2*u[n, i] - u[n - 1, i] +
                          r_sq * (u[n, i + 1] - 2*u[n, i] + u[n, i - 1]))
        # Boundaries remain at 0
        u[n + 1, 0] = 0
        u[n + 1, -1] = 0

    return x, t, u

# Parameters
c = 1.0    # wave speed
L = 1.0    # domain length
T = 2.0    # total time
nx = 101   # spatial points
nt = 200   # time steps

# Solve
x, t, u = solve_wave_equation_1d(c, L, T, nx, nt)

# Analytical solution: u(x,t) = sin(2*pi*x)*cos(2*pi*c*t)
def analytical_solution(x, t, c):
    return np.sin(2 * np.pi * x) * np.cos(2 * np.pi * c * t)

# Plot at different times
fig, axes = plt.subplots(3, 3, figsize=(15, 12))
times_to_plot = [0, 0.125, 0.25, 0.375, 0.5, 0.625, 0.75, 0.875, 1.0]
axes = axes.flatten()

for idx, time in enumerate(times_to_plot):
    n = int(time / T * nt)
    u_analytical = analytical_solution(x, t[n], c)

    axes[idx].plot(x, u[n, :], 'o-', label='Numerical', markersize=3, alpha=0.7)
    axes[idx].plot(x, u_analytical, '--', label='Analytical', linewidth=2)
    axes[idx].set_xlabel('x')
    axes[idx].set_ylabel('u(x, t)')
    axes[idx].set_title(f't = {time:.3f} s')
    axes[idx].legend(fontsize=8)
    axes[idx].grid(True, alpha=0.3)
    axes[idx].set_ylim(-1.2, 1.2)

plt.tight_layout()
plt.savefig('wave_equation_1d.png', dpi=150)
plt.show()

# Calculate maximum error over all time
errors = np.zeros(nt + 1)
for n in range(nt + 1):
    u_analytical = analytical_solution(x, t[n], c)
    errors[n] = np.max(np.abs(u[n, :] - u_analytical))

plt.figure(figsize=(10, 6))
plt.semilogy(t, errors, linewidth=2)
plt.xlabel('Time t')
plt.ylabel('Maximum Error (log scale)')
plt.title('Error Evolution Over Time')
plt.grid(True, alpha=0.3)
plt.tight_layout()
plt.savefig('wave_equation_error.png', dpi=150)
plt.show()

print(f"\\nMaximum error over all time: {np.max(errors):.6f}")
print(f"Final error at t={T}: {errors[-1]:.6f}")
\`\`\`

**Expected Output:**
\`\`\`
Courant number = 1.0000 (must be <= 1.0)
Maximum error over all time: 0.002341
Final error at t=2.0: 0.001234
\`\`\`

**Key Observations:**
- Wave propagates without dissipation (energy conservation)
- Wave reflects at boundaries
- Period = 1/c = 1 second
- Leapfrog scheme maintains good accuracy for waves

</details>

---

## Part 3: Connecting to PINNs

### Why These Skills Matter for PINNs

1. **Understanding PDEs**: PINNs encode PDE residuals in the loss function
2. **Numerical Methods Baseline**: Compare PINN solutions against traditional solvers
3. **Initial/Boundary Conditions**: Know how to properly specify constraints
4. **Solution Behavior**: Recognize physically realistic vs unrealistic solutions
5. **Error Analysis**: Validate PINN accuracy against known solutions

### Next Steps

Now that you've mastered numerical methods, you're ready to:

1. Implement PINNs that solve the same problems using neural networks
2. Compare PINN efficiency vs finite differences
3. Tackle inverse problems (parameter identification)
4. Solve PDEs in complex geometries where finite differences struggle

---

## Summary

**What You Learned:**

‚úÖ Analytical solutions to simple ODEs
‚úÖ Euler method implementation and limitations
‚úÖ Runge-Kutta 4th order (RK4) for accurate ODE solving
‚úÖ Systems of ODEs (harmonic oscillator)
‚úÖ Finite difference approximations
‚úÖ Explicit method for heat equation
‚úÖ Leapfrog scheme for wave equation
‚úÖ Stability conditions (CFL, diffusion)
‚úÖ Error analysis and validation

**Time to Complete:** 15-20 hours

**Next Guide:** [PINNs Implementation Guide](pinns_implementation_guide.html)

---

## Additional Resources

- [Paul's Online Notes - Differential Equations](https://tutorial.math.lamar.edu/classes/de/de.aspx)
- [Steve Brunton: Differential Equations & Dynamical Systems](https://www.youtube.com/playlist?list=PLMrJAkhIeNNTYaOnVI3QpH7jgULnAmvPA)
- [LibreTexts: Introduction to PDEs](https://math.libretexts.org/Bookshelves/Differential_Equations/Introduction_to_Partial_Differential_Equations_(Herman))
- [Numerical Recipes in Python](http://numerical.recipes/)

`;

        // Render markdown
        document.getElementById('guide-content').innerHTML = marked.parse(markdown);
    </script>
</body>
</html>
